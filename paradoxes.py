# -*- coding: utf-8 -*-
"""Paradoxes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hs1VABU8CWx4Ldd2jxRwuiIpHcXtMURu
"""

from manim import *
import math
import numpy as np
from manim_slides import *
import random
from MF_Tools import *
import os
os.environ["PATH"] = "/Library/TeX/texbin:" + os.environ["PATH"]

## Global Variables and Stuff ##
#config.media_embed = True
DELAY = 0.1

# latex preamble
texPre = TexTemplate()
texPre.add_to_preamble(r"""
    \usepackage{amsmath}
    \usepackage{amssymb}
    \newcommand{\P}{\mathbb{P}}
""")

# tex color dictionary
E_color = GREY_B

t2cD = {
    "\P" : E_color,
}

# font sizes
my_fs = 75

#%%manim -ql -v WARNING OpeningScene

class OpeningScene3(Slide):
    def pause(self):
        #self.wait(DELAY)
        self.next_slide() #comment in for manim-slides
    
    def construct(self):
        # Titles
        Tuesday_color = BLUE #"#73d2de"
        text_fs = 34
        title_fs = 34
        paradox_fs = 36
        title_color = GREY_A
        
        paradox_txt = Text("Paradox:", font_size=paradox_fs,color=title_color)
        paradox_width = paradox_txt.get_width()
       
        titles = VGroup(
        VGroup(Text("Birthday", font_size=title_fs,color=title_color).set_width(paradox_width), paradox_txt.copy()).arrange(DOWN,buff=0.05),
        VGroup(Text("Two Child", font_size=title_fs,color=title_color).set_width(paradox_width), paradox_txt.copy()).arrange(DOWN,buff=0.05),
        VGroup(Text("Two Child", font_size=title_fs,color=title_color).set_width(paradox_width),Text("2 Tuesday", font_size=title_fs,color=Tuesday_color).set_width(paradox_width), paradox_txt.copy()).arrange(DOWN,buff=0.05),
        VGroup(Text("Disease Test", font_size=title_fs,color=title_color).set_width(paradox_width), paradox_txt.copy()).arrange(DOWN,buff=0.05)
        ) #.arrange(DOWN, aligned_edge=RIGHT)

        print(len(titles))


        answer_color = GREEN
        
        # Explanations
        math_fs = 60 #text_fs*2.0
        texts = VGroup(
        VGroup(Text("Among 23 people, what is the chance two share a birthday?", font_size=text_fs),MathTex(r"\text{Answer: }",r"\approx 50.7\%",font_size=math_fs)).arrange(DOWN,aligned_edge=LEFT,buff=0.05),
        VGroup(Text("Mr. Smith has two kids. Given that at least one of them \nis a boy, what is the chance that both are boys?", font_size=text_fs),MathTex(r"\text{Answer: }",r"\approx 33.3\%",font_size=math_fs)).arrange(DOWN,aligned_edge=LEFT,buff=0.05),
        VGroup(Text("Mr. Smith has two kids. Given that at least one of them is a boy\n born on a Tuesday, what is the chance that both are boys?", t2c={"born on a Tuesday": Tuesday_color}, t2w={"born on a Tuesday": BOLD}, font_size=text_fs).scale(0.85),MathTex(r"\text{Answer: }",r"\approx 48.1\%",font_size=math_fs)).arrange(DOWN,aligned_edge=LEFT,buff=0.05),
        VGroup(Text("How can a test for a disease that is 99% accurate\nonly be correct less than 10% of the time?", t2c={"less than 10%": answer_color},font_size=text_fs), MathTex("a","b","c"))
        ).arrange(DOWN, aligned_edge=LEFT, buff=0.4)

        print(len(texts))
        
        master_title = MarkupText(
            "<u>3 Classic Probability Paradoxes</u>", font_size=70
        ).to_edge(UP,buff=0.1)

        self.pause()
        self.play(Write(master_title))
        self.pause()

        pre_title_fs = 55
        pre_titles = VGroup(Text("The Birthday Paradox", font_size=pre_title_fs ), Text("The Two Child Paradox", font_size=pre_title_fs ), Text("The Disease Test Paradox", font_size=pre_title_fs ))
        pre_titles.next_to(master_title,DOWN,buff=0.4)
        for i in range(1,len(pre_titles)):
            pre_titles[i].shift(i*DOWN*0.8)
        pre_titles.next_to(master_title,DOWN,buff=0.4)
        self.play(Write(pre_titles[0]))
        self.pause()
        self.play(Write(pre_titles[1]))
        self.pause()
        self.play(Write(pre_titles[2]))
        self.pause()
        
        self.play(FadeOut(pre_titles[1:]))
        



        texts.next_to(master_title,DOWN,buff=0.4)
        texts.to_edge(RIGHT)

        for i in range(len(texts)):
            texts[i][1][0].set_color( GREY_B  )
            texts[i][1][1].set_color( answer_color )

        titles.next_to(texts,LEFT)

        # Place side by side like a table
        content = VGroup()
        for title, text in zip(titles, texts):
            title.next_to(text,LEFT,buff=0.2)
            title.align_to(text,UP)
            row = VGroup(title, text) #.arrange(RIGHT, buff=0.5)
            content.add(row)
            #self.add(content)
        #return 0

        #content.arrange(DOWN) #, aligned_edge=LEFT, buff=1)
        #content.scale(0.9).to_edge(LEFT)


        content.to_edge(RIGHT)
        #self.play(Write(content[0][0]))
        self.play(Transform(pre_titles[0],content[0][0]))
        self.play(Write(content[0][1][0]))
        self.pause()

        self.play(Write(content[0][1][1]))
        self.pause()

        self.play(Write(content[1][0]))
        self.play(Write(content[1][1][0]))
        self.pause()

        self.play(Write(content[1][1][1]))
        self.pause()

        #self.play(Write(content))
        #self.wait(3)
        self.play(ReplacementTransform(content[1][0].copy(),content[2][0]))
        self.pause()
        self.play(ReplacementTransform(content[1][1][0].copy(),content[2][1][0]))
        self.pause()
        self.play(Write(content[2][1][1]))
        self.pause()    

        self.play(FadeOut(content[2]))
        self.pause()

        content[3].next_to(content[2]).align_to(content[2],LEFT)
        self.play(Write(content[3][0]))
        self.play(Write(content[3][1][0]))
        self.pause()
        



class OpeningSceneOLD(Slide):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.skip_reversing = True  # Skip generating reversed animations

    def pause(self):
        self.next_slide() #comment in for manim-slides
        self.wait(DELAY)
        
    def construct(self):
        # Titles
        Tuesday_color = BLUE #"#73d2de"
        text_fs = 34
        title_fs = 34
        paradox_fs = 36
        title_color = GREY_A

        paradox_txt = Text("Paradox:", font_size=paradox_fs,color=title_color)
        paradox_width = paradox_txt.get_width()

        titles = VGroup(
        VGroup(Text("Birthday", font_size=title_fs,color=title_color).set_width(paradox_width), paradox_txt.copy()).arrange(DOWN,buff=0.05),
        VGroup(Text("Two Child", font_size=title_fs,color=title_color).set_width(paradox_width), paradox_txt.copy()).arrange(DOWN,buff=0.05),
        VGroup(Text("Two Child", font_size=title_fs,color=title_color).set_width(paradox_width),Text("2 Tuesday", font_size=title_fs,color=Tuesday_color).set_width(paradox_width), paradox_txt.copy()).arrange(DOWN,buff=0.05),
        VGroup(Text("Disease Test", font_size=title_fs,color=title_color).set_width(paradox_width), paradox_txt.copy()).arrange(DOWN,buff=0.05)
        ) #.arrange(DOWN, aligned_edge=RIGHT)

        print(len(titles))


        answer_color = GREEN

        # Explanations
        math_fs = 60 #text_fs*2.0
        texts = VGroup(
        VGroup(Text("Among 23 people, what is the chance two share a birthday?", font_size=text_fs),MathTex(r"\text{Answer: }",r"\approx 50.7\%",font_size=math_fs)).arrange(DOWN,aligned_edge=LEFT,buff=0.05),
        VGroup(Text("Mr. Smith has two kids. Given that at least one of them \nis a boy, what is the chance that both are boys?", font_size=text_fs),MathTex(r"\text{Answer: }",r"\approx 33.3\%",font_size=math_fs)).arrange(DOWN,aligned_edge=LEFT,buff=0.05),
        VGroup(Text("Mr. Smith has two kids. Given that at least one of them is a boy\n born on a Tuesday, what is the chance that both are boys?", t2c={"born on a Tuesday": Tuesday_color}, t2w={"born on a Tuesday": BOLD}, font_size=text_fs).scale(0.85),MathTex(r"\text{Answer: }",r"\approx 48.1\%",font_size=math_fs)).arrange(DOWN,aligned_edge=LEFT,buff=0.05),
        VGroup(Text("How can a test for a disease that is 99% accurate\nonly be correct less than 10% of the time?", t2c={"less than 10%": answer_color},font_size=text_fs), MathTex("a","b","c"))
        ).arrange(DOWN, aligned_edge=LEFT, buff=0.4)

        print(len(texts))

        master_title = MarkupText(
            "<u>3 Classic Probability Paradoxes</u>", font_size=60
        ).to_edge(UP,buff=0.1)

        self.add(master_title)

        texts.next_to(master_title,DOWN,buff=0.4)
        texts.to_edge(RIGHT)

        for i in range(len(texts)):
            texts[i][1][0].set_color( GREY_B  )
            texts[i][1][1].set_color( answer_color )

        titles.next_to(texts,LEFT)

        # Place side by side like a table
        content = VGroup()
        for title, text in zip(titles, texts):
            title.next_to(text,LEFT,buff=0.2)
            title.align_to(text,UP)
            row = VGroup(title, text) #.arrange(RIGHT, buff=0.5)
            content.add(row)
            #self.add(content)
        #return 0

        #content.arrange(DOWN) #, aligned_edge=LEFT, buff=1)
        #content.scale(0.9).to_edge(LEFT)


        content.to_edge(RIGHT)
        self.play(Write(content[0][0]))
        self.play(Write(content[0][1][0]))
        self.pause()

        self.play(Write(content[0][1][1]))
        self.pause()

        self.play(Write(content[1][0]))
        self.play(Write(content[1][1][0]))
        self.pause()

        self.play(Write(content[1][1][1]))
        self.pause()

        #self.play(Write(content))
        #self.wait(3)
        self.play(ReplacementTransform(content[1][0].copy(),content[2][0]))
        self.pause()
        self.play(ReplacementTransform(content[1][1][0].copy(),content[2][1][0]))
        self.pause()
        self.play(Write(content[2][1][1]))
        self.pause()

        self.play(FadeOut(content[2]))
        self.pause()

        content[3].next_to(content[2]).align_to(content[2],LEFT)
        self.play(Write(content[3][0]))
        self.play(Write(content[3][1][0]))
        self.pause()

def labelled_hat(location = ORIGIN, txt = "1", hat_color = "#ffbc42", my_scale = 1):
    # Triangular hat above head
    hat = Polygon(
        location + LEFT*0.5*my_scale + DOWN*0.1*my_scale,
        location + RIGHT*0.5*my_scale + DOWN*0.1*my_scale,
        location + UP*0.8*my_scale,
        color=hat_color,
        fill_opacity=1
    )
    pom_pom = Circle(radius=0.1, color=WHITE, fill_opacity=1).move_to(hat.get_top())

    # Label on head
    label = Text(txt, font_size=60, color = WHITE, stroke_width=2,stroke_color=BLACK ,weight=BOLD)   # Outline color)
    if label.width > label.height:
        label.width = 0.5*my_scale
    else:
        label.height = 0.5*my_scale
    if txt == "-":
        label.scale(my_scale).move_to(hat).shift(DOWN*0.05*my_scale)
    else:
        label.move_to(hat).align_to(hat,DOWN).shift(UP*0.05*my_scale)

    return VGroup(hat, pom_pom, label)

def stick_man(eye_angle = 0.1, my_scale = 0.5, txt = "1", hat_color = "#ffbc42"):
    # Head
    head = Circle(radius=0.7, fill_opacity=1,color=WHITE ).shift(UP * 0.5)

    # Draw the spider's eyes
    eye1 = Circle(radius=0.25, color=BLACK, fill_opacity=1).shift(UP * 0.7 + LEFT * 0.3)
    eye2 = Circle(radius=0.25, color=BLACK, fill_opacity=1).shift(UP * 0.7 + RIGHT * 0.3)

    # Add eyeballs to the eyes
    eye_x = np.cos(eye_angle)*0.1
    eye_y = np.sin(eye_angle)*0.1
    eyeball1 = Circle(radius=0.1, color=WHITE, fill_opacity=1).shift(UP * 0.7 + RIGHT*eye_x + UP*eye_y + LEFT * 0.3)
    eyeball2 = Circle(radius=0.1, color=WHITE, fill_opacity=1).shift(UP * 0.7 + RIGHT*eye_x + UP*eye_y + RIGHT * 0.3)

    # Triangular hat above head
    my_hat = labelled_hat(head.get_top(), txt, hat_color)
    #hat = Polygon(
    #    head.get_top() + LEFT*0.5 + DOWN*0.1,
    #    head.get_top() + RIGHT*0.5 + DOWN*0.1,
    #    head.get_top() + UP*0.8,
    #    color=hat_color,
    #    fill_opacity=1
    #)
    #pom_pom = Circle(radius=0.1, color=WHITE, fill_opacity=1).move_to(hat.get_top())

    # Label on head
    #label = Text(txt, font_size=60, color = WHITE, stroke_width=2,stroke_color=BLACK ,weight=BOLD)   # Outline color)
    #label.move_to(hat).align_to(hat,DOWN).shift(UP*0.05)

    # Body
    body = Line(head.get_bottom(), head.get_bottom() + DOWN * 1.5)

    # Arms (sloped downward from shoulders)
    shoulder_y = head.get_bottom()[1] - 0.3
    arms = VGroup(
        Line(start=[0, shoulder_y, 0], end=[-0.8, shoulder_y - 0.4, 0]),  # Left arm sloping down
        Line(start=[0, shoulder_y, 0], end=[0.8, shoulder_y - 0.4, 0])   # Right arm sloping down
    )

    # Legs (from bottom of body)
    leg_start = body.get_end()
    legs = VGroup(
        Line(leg_start, leg_start + DOWN * 1 + LEFT * 0.5),  # Left leg
        Line(leg_start, leg_start + DOWN * 1 + RIGHT * 0.5)  # Right leg
    )

    # Group and display
    return VGroup(head, eye1, eye2, eyeball1, eyeball2, body, arms, legs, my_hat).scale(my_scale)

#%%manim -ql -v WARNING BirthdayParadox
# Choose to do regular manim or manim-slides by choosing the correct jupyter magic. Must be first line.

class BirthdayParadox(Slide):  # Scene): # change to MyScene(Slide) for manim-slides
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.skip_reversing = True  # Skip generating reversed animations

    def pause(self):
        self.next_slide() #comment in for manim-slides
        self.wait(DELAY)
        
    def construct(self):


        def person_k_enters_node(hat_color,hat_label):
            my_hat = labelled_hat(ORIGIN, txt=hat_label, hat_color = hat_color)
            text = Text(" enters", font_size=60)
            text.next_to(my_hat,RIGHT)   # Outline color)
            rect = SurroundingRectangle(VGroup(my_hat,text), color=WHITE, buff=0.2)  #.set_stroke(BLACK, 3, 1)text, buff=0.1)
            return VGroup(rect,my_hat,text).scale(0.75)


        def add_layer(root_node, node_left, node_right, left_label_txt, right_label_txt):

            # Bottom center of the node
            bottom_center = root_node.get_bottom()

            # Arrow parameters
            offset = root_node.get_width()/2      # horizontal distance
            arrow_length = root_node.get_width()/3 # vertical distance
            left_color = GREEN_B
            right_color = RED_A
            # Create arrows
            arrow_left = Arrow(
                start=bottom_center,
                end=bottom_center + LEFT*offset + DOWN*arrow_length,
                buff=0,
                color = left_color
            )
            arrow_right = Arrow(
                start=bottom_center,
                end=bottom_center + RIGHT*offset + DOWN*arrow_length,
                buff=0,
                color = right_color
            )

            # Add labels to arrows
            label_fs = 35
            label_left = MathTex(left_label_txt, font_size=label_fs,color = left_color).next_to(arrow_left,LEFT,buff=0.01) #.align_to(arrow_left,DOWN)
            label_right = MathTex(right_label_txt, font_size=label_fs,color = right_color).next_to(arrow_right,RIGHT,buff=0.01) #.align_to(arrow_right,DOWN)

            # Add child nodes at arrow tips
            node_left.move_to(arrow_left.get_end()) # Rectangle(width=1, height=0.5, color=GREEN).move_to(arrow_left.get_end())
            node_left.align_to(arrow_left.get_end(),UP)
            node_right.move_to(arrow_right.get_end()) # Rectangle(width=1, height=0.5, color=GREEN).move_to(arrow_right.get_end())
            node_right.align_to(arrow_right.get_end(),UP)
            return VGroup(arrow_left, arrow_right, label_left, label_right)

        self.next_section() #skip_animations=True)
        colors = ["#ffbe0b", "#fb5607", "#ff006e", "#8338ec", "#3a86ff"]
        labels = ["1","2","3","4","23"]
        figures = VGroup(*[stick_man(txt=labels[i],hat_color = colors[i]) for i in range(5)]).arrange(RIGHT)

        figures.shift(DOWN*1.5)
        dotdotdot = MathTex(r"\cdots", font_size=60)
        figures[4].shift(RIGHT*dotdotdot.get_width())
        dotdotdot.next_to(figures[4],LEFT)

        problem = Text("Find the probability of a birthday match among 23 people.", font_size=32)
        assumption = Text("Assumptions: All birthdays uniform (each day 1/365 chance) and independent.", font_size=32)
        question = Text("Why is this hard?", font_size=32)
        ans = Text("Because of dependence!", font_size=32)
        solution = Text("Idea: Use a probability tree to break down dependent events.", font_size=32)
        problem.to_edge(UP)
        assumption.next_to(problem,DOWN)
        my_group = VGroup(question,ans).arrange(RIGHT)
        my_group.next_to(assumption,DOWN)
        solution.next_to(my_group,DOWN)

        self.pause()
        self.play(FadeIn(figures,dotdotdot))
        
        self.pause()
        self.play(Write(problem))
        self.pause()

        self.play(Write(assumption))
        self.pause()

        self.play(Write(question))
        self.pause()


        self.play(Write(ans))
        self.pause()

        self.play(Write(solution))
        self.pause()

        all_group = VGroup(problem,assumption,question,ans,solution,dotdotdot)


        figures[0].generate_target()

        figures[0].target.to_edge(RIGHT)
        self.play(FadeOut(figures[1:]),FadeOut(all_group),MoveToTarget(figures[0]))
        figures[1:].arrange(LEFT).next_to(figures[0],LEFT)
        self.pause()

        k_min = 2
        k_max = 5
        nodes = VGroup(*[person_k_enters_node(hat_color=colors[k-1],hat_label=labels[k-1]) for k in range(k_min,k_max+1)])
        nodes_match = VGroup(*[Paragraph(f"First Match\nPerson #{labels[k-k_min+1]}",font_size=30,alignment="center") for k in range(k_min,k_max+1)])
        layers = VGroup()
        all_unique_node = Paragraph("All Different\n Birthdays!",font_size=30,alignment="center")
        nodes[0].to_edge(UP)
        nodes[0].to_edge(LEFT,buff=1.3)
        for k in range(k_min,k_max):
            layer = add_layer(nodes[k-k_min], nodes_match[k-k_min], nodes[k-k_min+1], r"\frac{"+str(k-1)+"}{365}", r"\frac{"+str(365-k+1)+"}{365}")
            layers += layer
            #self.add(nodes[k-k_min],layer,nodes_match[k-k_min],nodes[k-k_min+1])
            #self.pause()
        k_max_label = 23
        layer = add_layer(nodes[k_max-k_min], nodes_match[k_max-k_min], all_unique_node, r"\frac{"+str(k_max_label-1)+"}{365}", r"\frac{"+str(365-k_max_label+1)+"}{365}")
        layers += layer
        #self.add(nodes[k_max-k_min],layer,nodes_match[k_max-k_min],all_unique_node)
        ddots = MathTex(r"\ddots", font_size=80)
        arrow_tip = layers[2][1].get_end()
        ddots.next_to(arrow_tip,RIGHT,buff=0).align_to(arrow_tip,UP).shift(0.05*DOWN)
        d_shift = ddots.get_height()+0.05
        r_shift = d_shift
        nodes[-1].shift(DOWN*d_shift + RIGHT*r_shift)
        nodes_match[-1].shift(DOWN*d_shift+ RIGHT*r_shift)
        layers[-1].shift(DOWN*d_shift+ RIGHT*r_shift)
        all_unique_node.shift(DOWN*d_shift+ RIGHT*r_shift)
        #my_tree = VGroup(nodes,layers,nodes_match,all_unique_node,ddots).scale(0.75).to_corner(UL)
        #self.add(nodes, layers, nodes_match, all_unique_node,ddots)
        #self.wait(5)
        arrow_tip = layers[0][1].get_end()
        all_unique_node.move_to(arrow_tip).align_to(arrow_tip,UP).shift(0.05*DOWN)

        figures[1].generate_target()
        figures[1].next_to(nodes[0],RIGHT)
        figures[1].align_to(figures[0],DOWN)
        self.play(Create(figures[1]))
        self.pause()


        self.play(MoveToTarget(figures[1]),Create(nodes[0]))
        self.pause()

        self.play(Create(layers[0][0])) #same birthday arrow
        self.play(Write(nodes_match[0])) #same birthday node
        self.play(Write(layers[0][2])) #same birthday P=
        self.pause()

        self.play(Create(layers[0][1])) #different birthday arrow
        self.play(Write(all_unique_node)) #different birthday node
        self.play(Write(layers[0][3])) #different birthday P=
        self.pause()


        figures[2].generate_target()
        figures[2].next_to(nodes[1],RIGHT)
        figures[2].align_to(figures[0],DOWN)
        self.play(Create(figures[2]))
        self.pause()

        all_unique_node_bak = all_unique_node.copy()
        self.play(MoveToTarget(figures[2]),ReplacementTransform(all_unique_node,nodes[1])) #,FadeOut(all_unique_node,shift=DOWN))
        self.pause()

        #all_unique_node.generate_target()
        arrow_tip = layers[1][1].get_end()
        all_unique_node = all_unique_node_bak.move_to(arrow_tip).align_to(arrow_tip,UP)

        self.play(Create(layers[1][0])) #same birthday arrow
        self.play(Write(nodes_match[1])) #same birthday node
        self.play(Write(layers[1][2])) #same birthday P=
        self.pause()

        #pause to write some stuff here
        cond_prob = VGroup(
            MathTex(r"\mathbb{P}\Big(",font_size=60),
            Text("Person #3 has first\n  birthday match",font_size=32), #,alignment="center"),
            MathTex(r"\mid",font_size=80),
            Paragraph("Person #1 and #2 have\ndifferent birthdays",font_size=32,alignment="center"),
            MathTex(r"\Big)",font_size=60),
            MathTex(r"=",font_size=40),
            MathTex(r"\frac{2}{365}",font_size=40),
        ).arrange(RIGHT,buff=0.12)
        cond_prob[-1].set_color(GREEN_A)
        cond_prob.to_corner(UR)
        self.play(Write(cond_prob))
        self.pause()
        self.play(FadeOut(cond_prob))
        self.pause()


        self.play(Create(layers[1][1])) #different birthday arrow
        self.play(Write(all_unique_node)) #different birthday node
        self.play(Write(layers[1][3])) #different birthday P=
        self.pause()


        #pause to write some stuff here
        text = VGroup(Text("Probability Multiplication Rule:", font_size=32),
                Text("Multiply along path to get probability of leaf event", font_size=28)).arrange(DOWN)

        math_1 = VGroup(
            MathTex(r"\mathbb{P}\Big(",font_size=40),
            Paragraph("All different birthdays\nafter 3 people",font_size=32,alignment="center"),
            MathTex(r"\Big) = \frac{364}{365} \times \frac{363}{365}",font_size=40)).arrange(RIGHT,buff=0.02)
        math_2 = MathTex(r"\mathbb{P}\Big(A \text{ and } B \Big) = \mathbb{P}(A) \mathbb{P}(B \mid A)",font_size=40)
        stuff = VGroup(text,math_1,math_2).arrange(DOWN,aligned_edge=RIGHT)
        stuff.to_corner(UR)
        uline = Underline(text[0])
        self.play(GrowFromCenter(uline),Write(text))
        self.play(Write(math_1))
        self.pause()
        self.play(Write(math_2))
        self.pause()

        self.play(FadeOut(stuff,uline,shift=DOWN))
        text = VGroup(Text("Probability Sum Rule:", font_size=32),
                Text("Add probabilities to combine disjoint events", font_size=28)).arrange(DOWN)

        math_1 = VGroup(
            MathTex(r"\mathbb{P}\Big(",font_size=40),
            Paragraph("Any birthday match\nafter 3 people",font_size=32,alignment="center"),
            MathTex(r"\Big)", r"=", r"\frac{1}{365} + \frac{364}{365} \times \frac{2}{365}",font_size=40)).arrange(RIGHT,buff=0.02)
        math_2 = MathTex(r"\mathbb{P}\Big(A \text{ or } B \Big) = \mathbb{P}(A) + \mathbb{P}(B)",font_size=40)

        stuff = VGroup(text,math_1,math_2).arrange(DOWN,aligned_edge=RIGHT)
        stuff.to_corner(UR)
        uline = Underline(text[0])
        self.play(GrowFromCenter(uline),Write(text))
        self.play(Write(math_1))
        self.pause()
        self.play(Write(math_2))
        self.pause()

        math_transformed = MathTex(r"\Big)", r"=", r"1 - \frac{364}{365}\times\frac{363}{365}",font_size=40)
        math_transformed.move_to(math_1[-1]).align_to(math_1[-1],LEFT)
        text2 = VGroup(Text("Total Probability Rule:", font_size=32),
                Text("All leafs together add to 100%", font_size=28)).arrange(DOWN)
        text2.move_to(text).align_to(text,UP)
        uline2 = Underline(text2[0])
        self.play(FadeOut(uline),GrowFromCenter(uline2),ReplacementTransform(text,text2))
        self.pause()

        self.play(TransformMatchingTex(math_1[-1],math_transformed),FadeOut(math_2,shift=DOWN))
        self.pause()



        #all_unique_node.generate_target()
        arrow_tip = layers[2][1].get_end()
        all_unique_node.generate_target()
        all_unique_node.target.move_to(arrow_tip).align_to(arrow_tip,UP)


        figures[3].generate_target()
        figures[3].next_to(nodes[2],RIGHT)
        figures[3].align_to(figures[0],DOWN)
        self.play(Create(figures[3]))
        self.play(MoveToTarget(figures[3]),FadeIn(nodes[2],layers[2],nodes_match[2],shift=DOWN), MoveToTarget(all_unique_node))
        self.pause()



        math_transformed_2 = MathTex(r"\Big)", r"=", r"1 - \frac{364}{365}\times\frac{363}{365}",r"\times \frac{362}{365}",font_size=40)
        math_1_0 = math_1[0].copy()
        math_1_1 = Paragraph("Any birthday match\nafter 4 people",font_size=32,alignment="center")
        my_group = VGroup(math_1_0,math_1_1,math_transformed_2).arrange(RIGHT,buff=0.02)
        my_group.move_to(math_1).align_to(math_1,RIGHT).shift(RIGHT*0.35)


        self.play(ReplacementTransform(math_1[0],math_1_0),ReplacementTransform(math_1[1],math_1_1),TransformMatchingTex(math_transformed,math_transformed_2))
        self.pause()

        #self.next_section()

        all_unique_node_copy = all_unique_node.copy()

        dotdotdot = MathTex(r"\cdots", font_size=60)
        dotdotdot.next_to(figures[3],LEFT)

        self.play(FadeOut(uline2,text2,shift=UP),ReplacementTransform(all_unique_node,ddots),FadeIn(dotdotdot,shift=RIGHT))
        self.pause()

        nodes.generate_target()
        nodes_match.generate_target()
        layers.generate_target()
        ddots.generate_target()
        my_scale_factor = 0.75
        my_tree = VGroup(ddots.target,nodes.target,nodes_match.target,layers.target).scale(my_scale_factor).to_corner(UL)
        arrow_tip = layers.target[3][1].get_end()
        all_unique_node_copy.move_to(arrow_tip).align_to(arrow_tip,UP).scale(my_scale_factor)

        figures[4].next_to(dotdotdot,LEFT)
        figures[4].align_to(figures[0],DOWN)



        self.play(FadeIn(figures[4],shift=RIGHT),FadeIn(all_unique_node_copy,shift=(UP+LEFT)),MoveToTarget(ddots),MoveToTarget(nodes),MoveToTarget(nodes_match),MoveToTarget(layers))
        self.pause()

        math_transformed_2_b = MathTex(r"\Big)", r"=", r"1 - \frac{364}{365}\times\frac{363}{365}",r"\times \frac{362}{365}",r"\times \cdots \times \frac{343}{365}",font_size=40)
        math_1_0_b = math_1[0].copy()
        math_1_1_b = Paragraph("Any birthday match\nafter 23 people",font_size=32,alignment="center")
        my_scale = 0.8
        my_group_b = VGroup(math_1_0_b,math_1_1_b,math_transformed_2_b).arrange(RIGHT,buff=0.02).scale(my_scale)
        my_group_b.move_to(math_1).align_to(math_1,RIGHT).shift(RIGHT*0.35)

        self.play(ReplacementTransform(math_1_0,math_1_0_b),ReplacementTransform(math_1_1,math_1_1_b),TransformMatchingTex(math_transformed_2,math_transformed_2_b))
        self.pause()

        my_ans_fs = 50
        final_ans_1 = MathTex(r"= 1-49.27..\%",font_size=my_ans_fs)
        final_ans_2 = MathTex(r"= 50.73..\%",font_size=my_ans_fs)
        final_ans_1.next_to(math_transformed_2_b,DOWN).align_to(math_transformed_2_b[1],LEFT)
        final_ans_2.next_to(final_ans_1,DOWN).align_to(final_ans_1,LEFT)
        self.play(Write(final_ans_1))
        self.play(Write(final_ans_2))
        self.pause()

def old_stick_man(eye_angle = 0.1, my_scale = 0.5, txt = "1", body_color = WHITE):
    # Head
    head = Circle(radius=0.7, fill_opacity=1,color=WHITE ).shift(UP * 0.5)
    # Draw the spider's eyes
    #eye1 = Circle(radius=0.25, color=BLACK, fill_opacity=1).shift(UP * 0.7 + LEFT * 0.3)
    #eye2 = Circle(radius=0.25, color=BLACK, fill_opacity=1).shift(UP * 0.7 + RIGHT * 0.3)
    # Add eyeballs to the eyes
    #eye_x = np.cos(eye_angle)*0.1
    #eye_y = np.sin(eye_angle)*0.1
    #eyeball1 = Circle(radius=0.1, color=WHITE, fill_opacity=1).shift(UP * 0.7 + RIGHT*eye_x + UP*eye_y + LEFT * 0.3)
    #eyeball2 = Circle(radius=0.1, color=WHITE, fill_opacity=1).shift(UP * 0.7 + RIGHT*eye_x + UP*eye_y + RIGHT * 0.3)
    #label = MathTex(txt, font_size=70, color = GREY_D)
    #label.align_to(head,DOWN)
    #label.shift(UP*0.1)
    # Body
    body = Line(head.get_bottom(), head.get_bottom() + DOWN * 1.5,color=body_color)
    # Arms (sloped downward from shoulders)
    shoulder_y = head.get_bottom()[1] - 0.3
    arms = VGroup(
        Line(start=[0, shoulder_y, 0], end=[-0.8, shoulder_y - 0.4, 0]),  # Left arm sloping down
        Line(start=[0, shoulder_y, 0], end=[0.8, shoulder_y - 0.4, 0])   # Right arm sloping down
    )
    # Legs (from bottom of body)
    leg_start = body.get_end()
    legs = VGroup(
        Line(leg_start, leg_start + DOWN * 1 + LEFT * 0.5),  # Left leg
        Line(leg_start, leg_start + DOWN * 1 + RIGHT * 0.5)  # Right leg
    )
    # Group and display
    return VGroup(head, body, arms, legs).scale(my_scale) #.set_z_index(2) #eye1, eye2, eyeball1, eyeball2,

def add_red_x(mobj, scale_factor=1.2, stroke_width=12, my_color = RED):
    """
    Returns a red X overlaying the given mobject.

    Args:
        mobj (Mobject): The mobject to overlay.
        scale_factor (float): How big the X is relative to the mobject’s bounding box.
        stroke_width (float): Thickness of the X lines.

    Returns:
        VGroup: The red X as a VGroup of two lines.
    """
    # Get bounding box corners
    ul = mobj.get_corner(UL)
    ur = mobj.get_corner(UR)
    ll = mobj.get_corner(DL)
    lr = mobj.get_corner(DR)

    # Compute center and size
    center = mobj.get_center()
    width = mobj.width * scale_factor
    height = mobj.height * scale_factor

    # Build X
    line1 = Line([-width/2, -height/2, 0], [width/2, height/2, 0], color=my_color, stroke_width=stroke_width)
    line2 = Line([-width/2, height/2, 0], [width/2, -height/2, 0], color=my_color, stroke_width=stroke_width)

    xmark = VGroup(line1, line2).move_to(center)

    return xmark

#%%manim -ql -v WARNING RareDiseaseTree
# Choose to do regular manim or manim-slides by choosing the correct jupyter magic. Must be first line.
class RareDiseaseTree(Slide):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.skip_reversing = True  # Skip generating reversed animations

    def pause(self):
        self.next_slide() #comment in for manim-slides
        self.wait(DELAY)
    def construct(self):

        self.pause()

        self.next_section() #skip_animations=True)

        has_disease_color = BLUE
        no_disease_color = GOLD
        positive_test_color = GREEN
        negative_test_color = RED
        text2color = {'Has disease.':has_disease_color, 'No disease.':no_disease_color, "Positive test.":positive_test_color, "Negative test.":negative_test_color}

        def disease_node(label_color, hat_label):
            """Create a node representing disease status or test result"""
            node_fs = 26
            label = Text(hat_label, font_size=node_fs, t2c=text2color)
            rect = SurroundingRectangle(label,color=WHITE)
            return VGroup(rect, label)

        def add_layer(root_node, node_left=None, node_right=None, left_label_txt="", right_label_txt="", left_color=GREEN_B, right_color=RED_A, h_offset = 1.8):
            """Add a layer of arrows and labels between parent and children nodes"""
            bottom_center = root_node.get_bottom()
            #h_offset = 1.8 #root_node.get_width()  # horizontal distance for arrows
            arrow_length = 1.5  # vertical distance
            objects = VGroup()

            label_fs = 34

            if node_left:
                # Left arrow
                left_offset = LEFT*h_offset if node_right else 0
                arrow_left = Arrow(
                    start=bottom_center,
                    end=bottom_center + left_offset + DOWN*arrow_length,
                    buff=0,
                    color=left_color
                )
                label_left = MathTex(left_label_txt, font_size=label_fs, color=left_color).next_to(arrow_left, LEFT, buff=0.1)
                node_left.move_to(arrow_left.get_end()).align_to(arrow_left.get_end(), UP)
                objects.add(arrow_left, label_left, node_left)

            if node_right:
                # Right arrow
                arrow_right = Arrow(
                    start=bottom_center,
                    end=bottom_center + RIGHT*h_offset + DOWN*arrow_length,
                    buff=0,
                    color=right_color
                )
                label_right = MathTex(right_label_txt, font_size=label_fs, color=right_color).next_to(arrow_right, RIGHT, buff=0.1)
                node_right.move_to(arrow_right.get_end()).align_to(arrow_right.get_end(), UP)
                objects.add(arrow_right, label_right, node_right)

            # Special case: only one node directly underneath
            #if node_left and not node_right:
            #
            #    node_left.align_to(arrow_left.get_end(), DOWN) #, buff=1.5)

            return objects

        # === Layer 1: Has disease? ===

        root = disease_node(WHITE, "Actual disease status?")
        root.to_edge(UP)

        has_disease = disease_node(has_disease_color, "Has disease.\nTest result?")
        no_disease = disease_node(no_disease_color, "No disease.\nTest result?")

        layer1 = add_layer(
            root,
            has_disease,
            no_disease,
            r"\frac{1}{1,001}",
            r"\frac{1,000}{1,001}",
            has_disease_color,
            no_disease_color
        )

        # === Layer 2: Tested positive? ===
        # Only draw the "Test positive" branch for "Has disease"
        test_yes_hd = disease_node(GREEN_B, "Has disease.\nPositive test.")
        layer2_hd = add_layer(
            has_disease,
            node_left=test_yes_hd,  # directly underneath
            node_right=None,
            left_label_txt=r"100\%",    # 100% chance
            right_label_txt = "",
            left_color = positive_test_color,
            right_color = negative_test_color
        )

        # For "No disease", normal left/right branching
        test_yes_nd = disease_node(GREEN_B, "No disease.\nPositive test.")
        test_no_nd = disease_node(RED_A, "No disease.\nNegative test.")
        layer2_nd = add_layer(
            no_disease,
            test_yes_nd,
            test_no_nd,
            r"1\%",  # 1% chance
            r"99\%",
            positive_test_color,
            negative_test_color,
            h_offset=1.2
        )
        problem_text = "<u>Rare Disease Testing Paradox:</u> A rare disease affects 1 in 1,001 people. The test for the disease is always positive if you have it, and is 99% accurate if you don't. Given that you have tested positive, what is the chance that you actually have the disease?"
        problem_statement = MarkupText(problem_text, width=config.frame_width-0.4, font_size=61, color=WHITE, justify=False).to_edge(UP)
        #problem_statement.width = 6.5  # shrink text to fit
        problem_statement.to_edge(UP,buff=0.1)
        self.play(Write(problem_statement),run_time=6)
        self.pause()


        # === Add all objects to scene ===
        tree_group = VGroup(root, has_disease, no_disease, layer1, layer2_hd, layer2_nd, test_yes_hd, test_yes_nd, test_no_nd)
        tree_group.next_to(problem_statement,DOWN)
        tree_group.to_edge(RIGHT,buff=0.25)
        self.play(Create(root))
        self.play(GrowFromEdge(layer1,UP))

        #self.play(Create(has_disease),Create(no_disease))
        self.pause()

        self.play(GrowFromEdge(layer2_hd,UP))
        #self.play(Create(test_yes_hd))
        self.play(GrowFromEdge(layer2_nd,UP))
        #self.play(Create(test_yes_nd),Create(test_no_nd))
        self.pause()

        #self.add(tree_group)

        fig_has_disease_positive = old_stick_man()
        fig_no_disease_positive_a = old_stick_man()
        ldots_one = MathTex(r"\ldots") #.scale(0.4)
        fig_no_disease_positive_b = old_stick_man()
        fig_no_disease_negative_a = old_stick_man()
        ldots_two = MathTex(r"\ldots\ldots") #.scale(0.4)
        fig_no_disease_negative_b = old_stick_man()

        #bracket_left = Brace(fig_has_disease_positive, direction=LEFT, buff=0.1)
        #bracket_right = Brace(fig_has_disease_positive, direction=RIGHT, buff=0.1)
        my_fig_group = VGroup(fig_has_disease_positive, fig_no_disease_positive_a, ldots_one, fig_no_disease_positive_b, fig_no_disease_negative_a, ldots_two, fig_no_disease_negative_b).arrange(RIGHT).scale(0.9).to_edge(LEFT)
        my_fig_group.scale(0.9).to_edge(LEFT,buff=0.7).shift(0.7*UP)
        #self.add(my_fig_group)

        brace_color = GREY_C

        ldots = VGroup(MathTex(r"\ldots"),MathTex(r"\ldots\ldots")).arrange(RIGHT).set_x(0.5*(my_fig_group[0].get_x()+my_fig_group[-1].get_x()))
        self.play(Create(my_fig_group[0]),Create(my_fig_group[-1]),Create(ldots))
        bracket_one= Brace(my_fig_group, direction=DOWN, buff=0.1,color=brace_color)
        bracket_one_label = Text("1,001 people.", font_size=32, color=WHITE).next_to(bracket_one, DOWN)

        self.play(Create(bracket_one),Write(bracket_one_label))
        self.pause()

        label_fs = 28
        bracket_two_a= Brace(fig_has_disease_positive, direction=DOWN, buff=0.1,color=brace_color)
        bracket_two_a_label = Text("1 person.\nHas disease.", font_size=label_fs, color=WHITE, t2c=text2color).next_to(bracket_two_a, DOWN) #.shift(RIGHT*0.5)
        bracket_two_b= Brace(my_fig_group[1:], direction=DOWN, buff=0.1,color=brace_color)
        bracket_two_b_label = Text("1,000 people.\nNo disease.", font_size=label_fs, color=WHITE, t2c=text2color).next_to(bracket_two_b, DOWN)

        self.play(ReplacementTransform(bracket_one,VGroup(bracket_two_a,bracket_two_b)),
                ReplacementTransform(bracket_one_label,VGroup(bracket_two_a_label,bracket_two_b_label)),
                FadeIn(my_fig_group[1],shift=LEFT),
                my_fig_group[0].animate.set_color(has_disease_color),
                my_fig_group[1].animate.set_color(no_disease_color),
                my_fig_group[-1].animate.set_color(no_disease_color),
                ldots.animate.set_x(0.5*(my_fig_group[1].get_x()+my_fig_group[-1].get_x())))
        self.pause()

        label_fs = 28
        x_shift = 0.5
        bracket_3_a= Brace(my_fig_group[1:3+1], direction=DOWN, buff=0.1,color=brace_color)
        bracket_3_a_label = Text("10 people.\nNo disease.\nPositive test.", font_size=label_fs, color=WHITE, t2c=text2color).next_to(bracket_3_a, DOWN).shift(RIGHT*x_shift)
        bracket_3_b= Brace(my_fig_group[4:], direction=DOWN, buff=0.1,color=brace_color)
        bracket_3_b_label = Text("990 people.\nNo disease.\nNegative test.", font_size=label_fs, color=WHITE, t2c=text2color).next_to(bracket_3_b, DOWN).shift(RIGHT*x_shift)

        pos_test = Text("Positive test.", font_size=label_fs, color=WHITE, t2c=text2color).align_to(bracket_3_a_label, DOWN).align_to(bracket_two_a_label,LEFT) #.shift(RIGHT*0.5)

        # Triangular hat above head
        hat_scale = 0.5

        pos_hat = labelled_hat(my_fig_group[0].get_top(), "+", positive_test_color, my_scale = hat_scale)
        self.play(FadeIn(pos_test,shift=DOWN,buff=0.01),FadeIn(pos_hat,shift=UP,buff=0.00))

        pos_1a_hat = labelled_hat(my_fig_group[1].get_top(), "+", positive_test_color, my_scale = hat_scale)
        pos_1b_hat = labelled_hat(my_fig_group[3].get_top(), "+", positive_test_color, my_scale = hat_scale)
        neg_1a_hat = labelled_hat(my_fig_group[-1].get_top(), "-", negative_test_color, my_scale = hat_scale)
        neg_1b_hat = labelled_hat(my_fig_group[-3].get_top(), "-", negative_test_color, my_scale = hat_scale)
        hats = VGroup(pos_1a_hat,pos_1b_hat,neg_1a_hat,neg_1b_hat)
        self.play(FadeIn(hats,shift=UP,buff=0.00),
                ReplacementTransform(bracket_two_b,VGroup(bracket_3_a,bracket_3_b)),
                ReplacementTransform(bracket_two_b_label,VGroup(bracket_3_a_label,bracket_3_b_label)),
                FadeIn(my_fig_group[3],shift=RIGHT),
                my_fig_group[3].animate.set_color(no_disease_color),
                FadeIn(my_fig_group[4],shift=LEFT),
                my_fig_group[4].animate.set_color(no_disease_color),
                ReplacementTransform(ldots, VGroup(my_fig_group[2],my_fig_group[-2])),
                )
        self.pause()


        #self.play(FadeOut(problem_statement))
        #self.pause()


        conditioning_text = "<u>Conditioning Rule:</u> Cut away the impossible, then renormalize what’s left."
        conditioning_mob = MarkupText(conditioning_text , width=config.frame_width-0.4, font_size=50, color=WHITE, justify=False).to_edge(UP,buff=0.3).set_z_index(1)
        my_buff = 0.2
        bak = BackgroundRectangle(conditioning_mob,fill_opacity=1.0,buff=my_buff)
        surround = SurroundingRectangle(conditioning_mob,color=WHITE,buff=my_buff).set_z_index(1)
        self.play(Write(conditioning_mob),FadeIn(bak,surround),problem_statement.animate.set_opacity(0.5))
        self.pause()

        x_color = GREY_B
        #tree_x = add_red_x(test_no_nd,my_color =  x_color )
        branch_x = add_red_x(layer2_nd[4:5+1],my_color = x_color )
        self.play(GrowFromCenter(branch_x))
        self.pause()

        ppl_x = add_red_x(my_fig_group[4:],my_color=x_color)
        bracket_x = add_red_x(bracket_3_b_label,my_color=x_color)
        self.play(GrowFromCenter(ppl_x),GrowFromCenter(bracket_x))
        self.pause()



        eqn_size = 50
        text_color_dict = {
            r"\text{Has disease}" : has_disease_color,
            r"\text{Test positive}" : positive_test_color
        }
        p_text = MathTex(r"\mathbb{P}\left( \text{Has disease} \mid \text{Test positive} ) = ",font_size = eqn_size, tex_to_color_map = text_color_dict)
        my_color_dict = {
            r"{1" : has_disease_color,
            r"\over 1,001}" : has_disease_color,

            r"{ 1,000 " : no_disease_color,
            r"{ 10 " : no_disease_color,
            r" \over 1,001}" : no_disease_color,

            r"100\%" : positive_test_color,
            r"1\%" : positive_test_color
        }
        ans = MathTex(r"{1", r"\over 1,001}", r"\times", r"100\%" ,r"\over", r"{1", r"\over 1,001}", r"\times",r"100\%","+",r"{ 1,000 ",r" \over 1,001}",r"\times", r"1\%",tex_to_color_map=my_color_dict)
        #print(*enumerate(ans),sep='\n')
        VGroup(p_text,ans).arrange(RIGHT).to_edge(UP)
        conditioning_mob.generate_target()
        conditioning_mob.target.scale(0.7).to_corner(UL,buff=0.15)
        self.play(LaggedStart(FadeOut(problem_statement),FadeOut(surround,bak), MoveToTarget(conditioning_mob),Write(p_text),lag_ratio=0.5))
        #FadeOut(bak,surround,problem_statement))
        self.play(Write(ans[0:3+1]))
        self.pause()

        self.play(LaggedStart(GrowFromEdge(ans[4],LEFT),Write(ans[5:]),lag_ratio=0.5))
        self.pause()

        ans2 = MathTex(r"{1", r"}", r"\times", r"100\%" ,r"\over", r"{1", r"}", r"\times",r"100\%","+",r"{ 1,000 ",r"}",r"\times", r"1\%",tex_to_color_map=my_color_dict)
        print(*enumerate(ans2),sep='\n')
        ans2.next_to(p_text,RIGHT)
        self.play(TransformMatchingTex(ans,ans2))
        self.pause()


        ans3 = MathTex(r"{1", r"}",r"\over", r"{1", r"}", "+",r"{ 10 ",r"}",tex_to_color_map=my_color_dict)
        one_top = MathTex("1",color=has_disease_color )
        one_top.move_to(ans2[2])
        one_bottom = one_top.copy()
        one_bottom.move_to(ans2[7])
        ten = MathTex("10",color=no_disease_color )
        ten.move_to(ans2[12])

        self.play(LaggedStart(Transform(ans2[0:3+1],one_top),
                Transform(ans2[5:8+1],one_bottom),
                Transform(ans2[10:],ten),lag_ratio=0.7))
        self.pause()

        ans3.next_to(p_text,RIGHT)
        my_key_map = {r"{ 1,000 " : r"{ 10 "}
        approx = MathTex(r"\approx 9.1\%")
        approx.next_to(ans3)
        self.play(LaggedStart(TransformMatchingTex(ans2,ans3,key_map=my_key_map),Write(approx),lag_ratio=0.7))
        self.pause()



def make_labeled_grid(labels, fractions, size=4,col_text = None,text2color=None):
    """
    Make a square grid subdivided according to fractions, with row/col labels.

    Args:
        labels (list[str]): list of names for rows/columns
        fractions (list[float]): fraction of total square for each row/column
                                 (must sum to 1)
        size (float): total side length of the big square

    Returns:
        VGroup containing squares, labels, and cell texts
    """
    n = len(labels)
    assert len(fractions) == n, "fractions must match labels length"
    assert abs(sum(fractions) - 1) < 1e-6, "fractions must sum to 1"

    # Compute widths/heights for each subdivision
    widths = [f * size for f in fractions]
    heights = [f * size for f in fractions]

    # Compute cumulative boundaries (left/right and top/bottom)
    x_edges = [-size/2]
    for w in widths:
        x_edges.append(x_edges[-1] + w)

    y_edges = [size/2]
    for h in heights:
        y_edges.append(y_edges[-1] - h)

    subsquares = []
    cell_texts = []

    for i in range(n):  # rows
        for j in range(n):  # cols
            # Rectangle defined by edges
            x0, x1 = x_edges[j], x_edges[j+1]
            y0, y1 = y_edges[i], y_edges[i+1]
            rect = Rectangle(width=x1-x0, height=y0-y1)
            rect.move_to([(x0+x1)/2, (y0+y1)/2, 0])
            subsquares.append(rect)

            # Cell label
            label = Text(f"{labels[i]}\n{labels[j]}",t2c= text2color).scale(0.5)
            if rect.height > 1.5*rect.width:
                label.rotate(PI/2)

            # Scale label down if it doesn't fit
            max_width = rect.width * 0.9   # leave a margin
            max_height = rect.height * 0.9
            if label.width > max_width or label.height > max_height:
                scale_factor = min(max_width / label.width, max_height / label.height)
                label.scale(scale_factor)

            label.move_to(rect.get_center())
            cell_texts.append(label)

    row_col_scale_factor = 0.75
    # Row labels (on the left)
    if col_text is None:
        col_text = labels
    col_labels = []
    row_labels = []
    for i in range(n):
        mid_y = (y_edges[i] + y_edges[i+1]) / 2
        label = Text(col_text[i],t2c= text2color).scale(row_col_scale_factor)
        label.next_to([x_edges[0], mid_y, 0], LEFT, buff=0.3)
        row_labels.append(label)

    # Column labels (on top)
    if col_text is None:
        col_text = labels
    col_labels = []
    for j in range(n):
        mid_x = (x_edges[j] + x_edges[j+1]) / 2
        label = Text(col_text[j],t2c= text2color).scale(row_col_scale_factor)
        label.next_to([mid_x, y_edges[0], 0], UP, buff=0.3)
        if col_labels:
                #label.align_to(col_labels[0],UP)
                label.set_y(col_labels[0].get_y())
        col_labels.append(label)

    #return VGroup(VGroup(*reversed(subsquares)), VGroup(*reversed(row_labels)), VGroup(*reversed(col_labels)), VGroup(*reversed(cell_texts)))
    return VGroup(VGroup(*reversed(subsquares)), VGroup(*row_labels), VGroup(*col_labels), VGroup(*reversed(cell_texts)))

#%%manim -ql -v WARNING TwoChild


class TwoChild(Slide):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.skip_reversing = True  # Skip generating reversed animations

    def pause(self):
        self.next_slide() #comment in for manim-slides
        self.wait(DELAY)
    def construct(self):
        self.pause()
        self.next_section() #skip_animations = True)

        boy_color = BLUE
        girl_color = PINK
        tu_color = GREEN
        not_tu_color = RED

        text2color = {
            r"Boy" : boy_color,
            r"Girl" : girl_color,
            r" Tu" : tu_color,
            r"\nTu" : tu_color,
            r"notTu" : not_tu_color
        }

        tex_color_dict = {
            r" 50\% " : boy_color,
            r"{50\%}" : girl_color,
            r"\frac{1}{7}" : tu_color,
            r"\frac{6}{7}" : not_tu_color
        }

        def node(label_color, hat_label):
            """Create a node representing disease status or test result"""
            node_fs = 26
            label = Text(hat_label, font_size=node_fs, t2c=text2color)
            rect = SurroundingRectangle(label,color=WHITE)
            return VGroup(rect, label)

        def add_layer(root_node, nodes = [], labels = [], colors = [], h_offset = 1.8, label_fs = 34):
            """Add a layer of arrows and labels between parent and children nodes"""
            bottom_center = root_node.get_bottom()
            #h_offset = 1.8 #root_node.get_width()  # horizontal distance for arrows
            arrow_length = 1.5  # vertical distance
            objects = VGroup()

            num_nodes = len(nodes)
            for i in range(num_nodes):
                offset = -(i + 0.5 - num_nodes/2 )*(h_offset)
                arrow = Arrow(
                    start=bottom_center,
                    end=bottom_center + offset*RIGHT + DOWN*arrow_length,
                    buff=0,
                    color=colors[i]
                )
                if offset < 0:
                    my_dir = LEFT
                elif offset > 0:
                    my_dir = RIGHT
                elif offset == 0:
                    my_dir = 0
                label = MathTex(labels[i], font_size=label_fs, tex_to_color_map=tex_color_dict).move_to(arrow)
                label.shift(my_dir*(0.15+label.get_width()/2))
                nodes[i].move_to(arrow.get_end()).align_to(arrow.get_end(), UP)
                objects.add(VGroup(nodes[i],arrow, label))

            return objects



        problem_text = "<u>Two Child Paradox:</u> Mr. Smith has two kids. Given that at least one of them is a boy, what is the chance that both are boys?"
        problem_mob = MarkupText(problem_text, width=config.frame_width-0.4, font_size=61, color=WHITE, justify=False).to_edge(UP)
        #problem_statement.width = 6.5  # shrink text to fit
        problem_mob.to_edge(UP,buff=0.1)

        self.play(Write(problem_mob,run_time=5))
        self.pause()

        assumption_text = "<u>Assumption:</u> Children are 50/50 boy/girl independently"
        assumption_mob = MarkupText(assumption_text, font_size=36, color=WHITE, justify=False)
        assumption_mob.next_to(problem_mob,DOWN).to_edge(LEFT,buff=0.1)

        self.play(Write(assumption_mob))
        self.pause()


        #self.add(problem_mob,assumption_mob)

        #return 0



        # === Layer 1: Has disease? ===

        root = node(WHITE, "1st child?")
        root.next_to(assumption_mob,DOWN).shift(3.3*RIGHT)

        boy_1 = node(boy_color, "   Boy  \n2nd child?")
        girl_1 = node(girl_color, "    Girl  \n2nd child?")

        layer1 = add_layer(
            root,
            [girl_1,boy_1],
            [r"{50\%}", r" 50\% "],
            [girl_color,boy_color],
            h_offset = 2
        )

        boy_2 = node(boy_color, " Boy")
        girl_2 = node(girl_color, "Girl")
        layer2 = VGroup()
        for i in range(2):
            layer2 += add_layer(
                layer1[i][0],
                 [girl_2.copy(), boy_2.copy()],
                [r"{50\%}",r" 50\% "],
                [girl_color, boy_color],
                label_fs = 25,
                h_offset = 1
                )


        boyTu_1b = node(boy_color, " Boy Tu \n2nd child?")
        boyNotTu_1b = node(boy_color, "Boy notTu \n2nd child?")
        girl_1b = node(girl_color, "    Girl  \n2nd child?")

        layer1_b = add_layer(
            root,
            [girl_1b, boyNotTu_1b, boyTu_1b],
            [r"{50\%}",r"\frac{6}{7} 50\% ",r"\frac{1}{7} 50\% "],
            [girl_color, boy_color, boy_color],
            h_offset = 3
        )

        boyTu_2b = node(boy_color, "Boy\n Tu")
        boyNotTu_2b = node(boy_color, "  Boy \n notTu")
        girl_2b = node(girl_color, "Girl")

        layer2_b = VGroup()
        for i in range(3):
            layer2_b += add_layer(
                layer1_b[i][0],
                 [girl_2b.copy(), boyNotTu_2b.copy(), boyTu_2b.copy()],
                [r"{50\%}",r"\frac{6}{7} 50\% ",r"\frac{1}{7} 50\% "],
                [girl_color, boy_color, boy_color],
                label_fs = 25,
                h_offset = 1
                )

        self.play(Create(root))
        self.play(GrowFromEdge(layer1,UP))
        self.pause()

        self.play(GrowFromEdge(layer2[0],UP))
        self.play(GrowFromEdge(layer2[1],UP))
        self.pause()


        g_labels = ["Boy", "Girl"]
        g_fractions = [0.5, 0.5]  # Must sum to 1
        g_size = 4  # total size of the big square
        g_scale = 0.8

        grid = make_labeled_grid(g_labels, g_fractions, g_size,text2color= text2color).scale(g_scale)
        grid.next_to(assumption_mob,DOWN,buff=0)
        grid.to_edge(LEFT)

        self.play(Write(grid))
        self.pause()

        x_color = GREY_C
        tree_x = add_red_x(layer2[0][0][0],my_color=x_color)
        self.play(Create(tree_x))
        self.pause()

        grid_x = add_red_x(grid[0][0],my_color=GREY_C)
        self.play(Create(grid_x))
        self.pause()

        tex_color_dict = {
            r"\text{Boy}" : boy_color,
            r"\text{Girl}" : girl_color,
            r"\text{Tu}" : tu_color
        }

        eqn_size = 40
        p_text = MathTex(r"\mathbb{P}\left( \text{Boy} \text{Boy} \mid \text{At least one } \text{Boy} ) = ",font_size = eqn_size, tex_to_color_map = tex_color_dict)
        my_color_dict = {
            r"{1" : boy_color,
            r"\over 2}" : boy_color,

            r"{ 1 " : girl_color,
            r" \over 2 }" : girl_color,
        }
        b_1 = r"{1"
        b_over_2 = r"\over 2}"
        g_1 = r"{ 1 "
        g_over_2 = r" \over 2 }"
        ans = MathTex(
            b_1, b_over_2, r"\cdot", b_1, b_over_2,
            r"\over",
            b_1, b_over_2, r"\cdot", b_1, b_over_2,
            r"+",
            g_1, g_over_2, r"\cdot", b_1, b_over_2,
            r"+",
            b_1, b_over_2, r"\cdot", g_1, g_over_2,
            tex_to_color_map=my_color_dict
        )

        VGroup(p_text,ans).arrange(RIGHT).to_edge(UP,buff=0.1)
        self.play(LaggedStart(FadeOut(problem_mob,assumption_mob),Write(p_text),lag_ratio=0.5))
        self.pause()

        self.play(Write(ans))
        self.pause()

        ans2 = MathTex(
            r"{", b_1, r"\cdot", b_1, r"}",
            r"\over",
            b_1, r"\cdot", b_1,
            r"+",
            g_1, r"\cdot", b_1,
            r"+",
            b_1, r"\cdot", g_1,
            tex_to_color_map=my_color_dict
        )

        ans2.next_to(p_text,RIGHT)
        self.play(TransformMatchingTex(ans,ans2))
        self.pause()

        one_third = MathTex(r"= \frac{1}{3}",font_size=eqn_size)
        one_third.next_to(ans2,RIGHT)
        self.play(Write(one_third))
        self.pause()


        self.play(FadeOut(p_text,ans2,one_third,tree_x,grid_x))

        Tuesday_color = GREEN
        text_fs = 38
        Tu_problem_mob = Text("Mr. Smith has two kids. Given that at least one of them is a boy \nborn on a Tuesday, what is the chance that both are boys?", t2c={"born on a Tuesday": Tuesday_color}, t2w={"born on a Tuesday": BOLD}, font_size=text_fs)
        Tu_problem_mob.to_corner(UL,buff=0.2)
        self.play(Write(Tu_problem_mob))
        self.pause()

        self.play(ReplacementTransform(layer1,layer1_b),ReplacementTransform(layer2,layer2_b))
        self.pause()

        g_labels = ["Boy Tu", "Boy notTu", "Girl"]
        g_col_text = ["Boy\n Tu", "  Boy\nnotTu", "Girl"]
        g_fractions = [0.17, 0.33, 0.5]  # Must sum to 1
        #size = 5  # total size of the big square


        grid2= make_labeled_grid(g_labels, g_fractions, g_size,col_text=g_col_text,text2color= text2color).scale(g_scale)
        grid2.move_to(grid)
        grid2.align_to(grid,DOWN).align_to(grid,RIGHT)
        self.play(ReplacementTransform(grid,grid2))
        self.pause()

        indices = [[0,0],[0,1],[1,0],[1,1]]
        tree_xs = VGroup()
        for i,j in indices:
            tree_xs.add(add_red_x(layer2_b[i][j][0],my_color=x_color))

        self.play(LaggedStart(*[Create(x) for x in tree_xs],lag_ratio=0.8))
        self.pause()

        indices = [0,1,3,4]
        grid_xs = VGroup()
        for i in indices:
            grid_xs.add(add_red_x(grid2[0][i],my_color=x_color))
        self.play(LaggedStart(*[Create(x) for x in grid_xs],lag_ratio=0.8))
        self.pause()


        indices = [[1,2],[2,1],[2,2]]
        hilite_color = YELLOW
        tree_hilites = []
        for i,j in indices:
            tree_hilites.append(layer2_b[i][j][0][0].animate.set_color(hilite_color))
        self.play(LaggedStart(*tree_hilites,lag_ratio=0.8))
        self.pause()

        indices = [5,7,8]
        grid_hilites = []
        for i in indices:
            grid_hilites.append(grid2[0][i].animate.set_color(hilite_color))
        self.play(LaggedStart(*grid_hilites,lag_ratio=0.8))
        self.pause()

        eqn_size = 40
        p_text = MathTex(r"\mathbb{P}\left( \text{Boy} \text{Boy} \mid \text{At least one } \text{Boy} \text{Tu} ) = ",font_size = eqn_size, tex_to_color_map = tex_color_dict)

        tu = r"\frac{1}{7}"
        not_tu = r"\frac{6}{7}"
        g = r" 1 "
        left_bra = r"\Big("
        right_bra = r"\Big)"

        my_color_dict = {
           tu : tu_color,
           not_tu : not_tu_color,
           g : girl_color,
           left_bra : hilite_color,
           right_bra : hilite_color
        }

        ans_tu = MathTex(
            r"{", left_bra, tu, r"\!\cdot\!", tu, "+", tu, r"\!\cdot\!", not_tu, "+", not_tu, r"\!\cdot\!", tu, right_bra, r"}",
            r"\over",
            left_bra, tu, r"\!\cdot\!", tu, "+", tu, r"\!\cdot\!", not_tu, "+", not_tu, r"\!\cdot\!", tu, right_bra, "+", tu, r"\!\cdot\!", g, "+", g, r"\!\cdot\!", tu,
            tex_to_color_map=my_color_dict
        )

        VGroup(p_text,ans_tu).scale(1.0).arrange(RIGHT,buff=0.2).to_edge(UP,buff=0.1)
        self.play(FadeOut(Tu_problem_mob),Write(p_text))
        self.play(Write(ans_tu))
        self.pause()


        frac = MathTex(r"=", r"\frac{13}{13 + 14}")
        p_text.generate_target()
        ans_tu.generate_target()
        scale_f = 0.8
        VGroup(p_text.target,ans_tu.target,frac).scale(scale_f).arrange(RIGHT,buff=0.2).to_edge(UP,buff=0.1)
        self.play(MoveToTarget(p_text),MoveToTarget(ans_tu),FadeIn(frac,shift=LEFT))
        self.pause()

        frac2 = MathTex(r"\approx", r"48.1\%").scale(scale_f).move_to(frac).align_to(frac,LEFT)
        self.play(TransformMatchingTex(frac,frac2,key_map={r"=":r"\approx", r"\frac{13}{13 + 14}":r"48.1\%"}))
        self.pause()
        #self.pause()
        #return 0
        return 0



        # === Add all objects to scene ===
        tree_group = VGroup(root, has_disease, no_disease, layer1, layer2_hd, layer2_nd, test_yes_hd, test_yes_nd, test_no_nd)
        tree_group.next_to(problem_statement,DOWN)
        tree_group.to_edge(RIGHT,buff=0.25)
        self.play(Create(root))
        self.play(GrowFromEdge(layer1,UP))

        #self.play(Create(has_disease),Create(no_disease))
        self.pause()

        self.play(GrowFromEdge(layer2_hd,UP))
        #self.play(Create(test_yes_hd))
        self.play(GrowFromEdge(layer2_nd,UP))
        #self.play(Create(test_yes_nd),Create(test_no_nd))
        self.pause()
